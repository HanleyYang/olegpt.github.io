<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://olegpt.top</id>
    <title>Oleg的博客</title>
    <updated>2020-10-29T12:54:01.897Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://olegpt.top"/>
    <link rel="self" href="https://olegpt.top/atom.xml"/>
    <logo>https://olegpt.top/images/avatar.png</logo>
    <icon>https://olegpt.top/favicon.ico</icon>
    <rights>All rights reserved 2020, Oleg的博客</rights>
    <entry>
        <title type="html"><![CDATA[70. Climbing Stairs]]></title>
        <id>https://olegpt.top/post/70-climbing-stairs/</id>
        <link href="https://olegpt.top/post/70-climbing-stairs/">
        </link>
        <updated>2020-08-04T12:37:24.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="70-climbing-stairs"><a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></h3>
<p>Difficulty: <strong>Easy</strong></p>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre>
<h4 id="1brute-force">1.Brute Force</h4>
<p>通过递归遍历所有可能性，方法出入栈的开销大，会超时。</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        return climbStairs(n, 0);
    }
    
    public int climbStairs(int n, int current) {
        if (current == n) return 1;
        if (current &gt; n) return 0;
        int count = 0;
        count += climbStairs(n, current + 1);
        count += climbStairs(n, current + 2);
        return count;
    }
}
</code></pre>
<h4 id="2dp">2.DP</h4>
<p>记录前两个元素的路径数，最终得到n的路径数</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        int dp[] = new int[n + 1];
        dp[1] = 1;
        dp[0] = 1;
        for (int i = 2; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<p>可以看出这里其实不需要用数组，只需要前两个元素即可：</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        int a = 0, b = 1;
        for (int i = 1; i &lt; n; i++) {
            if (i % 2 == 0) {
                b += a;
            } else {
                a += b;
            }
        }
        return a + b;
    }
}
</code></pre>
<h4 id="3斐波那契通项公式">3.斐波那契通项公式</h4>
<p>通过公式直接算出，建议自行学习原理</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="70-climbing-stairs"><a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></h3>
<p>Difficulty: <strong>Easy</strong></p>
<p>You are climbing a stair case. It takes <em>n</em> steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Note:</strong> Given <em>n</em> will be a positive integer.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre>
<h4 id="1brute-force">1.Brute Force</h4>
<p>通过递归遍历所有可能性，方法出入栈的开销大，会超时。</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        return climbStairs(n, 0);
    }
    
    public int climbStairs(int n, int current) {
        if (current == n) return 1;
        if (current &gt; n) return 0;
        int count = 0;
        count += climbStairs(n, current + 1);
        count += climbStairs(n, current + 2);
        return count;
    }
}
</code></pre>
<h4 id="2dp">2.DP</h4>
<p>记录前两个元素的路径数，最终得到n的路径数</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        int dp[] = new int[n + 1];
        dp[1] = 1;
        dp[0] = 1;
        for (int i = 2; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<p>可以看出这里其实不需要用数组，只需要前两个元素即可：</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        int a = 0, b = 1;
        for (int i = 1; i &lt; n; i++) {
            if (i % 2 == 0) {
                b += a;
            } else {
                a += b;
            }
        }
        return a + b;
    }
}
</code></pre>
<h4 id="3斐波那契通项公式">3.斐波那契通项公式</h4>
<p>通过公式直接算出，建议自行学习原理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路径问题的解法]]></title>
        <id>https://olegpt.top/post/zui-duan-lu-jing-wen-ti-de-jie-fa/</id>
        <link href="https://olegpt.top/post/zui-duan-lu-jing-wen-ti-de-jie-fa/">
        </link>
        <updated>2020-07-15T12:36:20.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[kudu的compaction机制]]></title>
        <id>https://olegpt.top/post/kudu-de-compaction-ji-zhi/</id>
        <link href="https://olegpt.top/post/kudu-de-compaction-ji-zhi/">
        </link>
        <updated>2020-07-07T12:43:10.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[739. Daily Temperatures]]></title>
        <id>https://olegpt.top/post/739-daily-temperatures/</id>
        <link href="https://olegpt.top/post/739-daily-temperatures/">
        </link>
        <updated>2020-07-01T12:40:45.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[287. Find the Duplicate Number]]></title>
        <id>https://olegpt.top/post/287-find-the-duplicate-number/</id>
        <link href="https://olegpt.top/post/287-find-the-duplicate-number/">
        </link>
        <updated>2020-06-17T12:34:49.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[3. Longest Substring Without Repeating Characters]]></title>
        <id>https://olegpt.top/post/3-longest-substring-without-repeating-characters/</id>
        <link href="https://olegpt.top/post/3-longest-substring-without-repeating-characters/">
        </link>
        <updated>2020-06-15T12:38:28.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[抽样算法之：水塘抽样（Reservoir Sampling）]]></title>
        <id>https://olegpt.top/post/chou-yang-suan-fa-zhi-shui-tang-chou-yang-reservoir-sampling/</id>
        <link href="https://olegpt.top/post/chou-yang-suan-fa-zhi-shui-tang-chou-yang-reservoir-sampling/">
        </link>
        <updated>2020-05-12T12:29:54.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[347. Top K Frequent Elements]]></title>
        <id>https://olegpt.top/post/347-top-k-frequent-elements/</id>
        <link href="https://olegpt.top/post/347-top-k-frequent-elements/">
        </link>
        <updated>2020-04-27T12:32:29.000Z</updated>
        <summary type="html"><![CDATA[<p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1], k = 1
Output: [1]
</code></pre>
<p><strong>Note:</strong></p>
<p>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.</p>
<h4 id="1bucketsort">1.BucketSort</h4>
<p>用frequencyMap统计每个数字出现的频率，然后将这些数字按出现频率添加到对应的桶中，最后从桶中由大到小取出k个数字。时间复杂度O(n)，空间复杂度O(n)</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;(k);
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        
        for (int i = 0; i &lt; nums.length; i++) {
            frequencyMap.put(nums[i],  frequencyMap.getOrDefault(nums[i], 0) + 1);
        }

        List&lt;Integer&gt;[] bucket = new LinkedList[nums.length + 1];
        for (Integer key : frequencyMap.keySet()) {
            Integer count = frequencyMap.get(key);
            if (bucket[count] == null) bucket[count] = new LinkedList&lt;&gt;();
            bucket[count].add(key);
        }

        int count = 0;
        for (int i = nums.length; count &lt; k &amp;&amp; i &gt;= 0; i--) {
            if (bucket[i] != null) {
                result.addAll(bucket[i]);
                count += bucket[i].size();
            }
        }
        return result;
    }
}

</code></pre>
<h4 id="2heapsort">2.HeapSort</h4>
<p>和上面桶排序的前半部分相同，最后将frequencyMap的结果写入到一个Heap中，Heap中包含了topK个数字。由于堆的插入排序耗时，所以时间复杂度为O(n logn)</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;(k);
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        
        for (int i = 0; i &lt; nums.length; i++) {
            frequencyMap.put(nums[i],  frequencyMap.getOrDefault(nums[i], 0) + 1);
        }

        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {
            public int compare(Map.Entry&lt;Integer, Integer&gt; e1, Map.Entry&lt;Integer, Integer&gt; e2) {
                return e2.getValue() - e1.getValue();
            }
        });

        for (Map.Entry&lt;Integer, Integer&gt; entry : frequencyMap.entrySet()) {
            heap.offer(entry);
        }

        for (int i = 0; i &lt; k; i++) {
            result.add(heap.poll().getKey());
        }

        return result;
    }
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
</code></pre>
<p><strong>Example 2:</strong></p>
<pre><code>Input: nums = [1], k = 1
Output: [1]
</code></pre>
<p><strong>Note:</strong></p>
<p>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>
Your algorithm's time complexity must be better than O(n log n), where n is the array's size.</p>
<h4 id="1bucketsort">1.BucketSort</h4>
<p>用frequencyMap统计每个数字出现的频率，然后将这些数字按出现频率添加到对应的桶中，最后从桶中由大到小取出k个数字。时间复杂度O(n)，空间复杂度O(n)</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;(k);
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        
        for (int i = 0; i &lt; nums.length; i++) {
            frequencyMap.put(nums[i],  frequencyMap.getOrDefault(nums[i], 0) + 1);
        }

        List&lt;Integer&gt;[] bucket = new LinkedList[nums.length + 1];
        for (Integer key : frequencyMap.keySet()) {
            Integer count = frequencyMap.get(key);
            if (bucket[count] == null) bucket[count] = new LinkedList&lt;&gt;();
            bucket[count].add(key);
        }

        int count = 0;
        for (int i = nums.length; count &lt; k &amp;&amp; i &gt;= 0; i--) {
            if (bucket[i] != null) {
                result.addAll(bucket[i]);
                count += bucket[i].size();
            }
        }
        return result;
    }
}

</code></pre>
<h4 id="2heapsort">2.HeapSort</h4>
<p>和上面桶排序的前半部分相同，最后将frequencyMap的结果写入到一个Heap中，Heap中包含了topK个数字。由于堆的插入排序耗时，所以时间复杂度为O(n logn)</p>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;(k);
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        
        for (int i = 0; i &lt; nums.length; i++) {
            frequencyMap.put(nums[i],  frequencyMap.getOrDefault(nums[i], 0) + 1);
        }

        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; heap = new PriorityQueue&lt;&gt;(new Comparator&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() {
            public int compare(Map.Entry&lt;Integer, Integer&gt; e1, Map.Entry&lt;Integer, Integer&gt; e2) {
                return e2.getValue() - e1.getValue();
            }
        });

        for (Map.Entry&lt;Integer, Integer&gt; entry : frequencyMap.entrySet()) {
            heap.offer(entry);
        }

        for (int i = 0; i &lt; k; i++) {
            result.add(heap.poll().getKey());
        }

        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[438. Find All Anagrams in a String]]></title>
        <id>https://olegpt.top/post/438-find-all-anagrams-in-a-string/</id>
        <link href="https://olegpt.top/post/438-find-all-anagrams-in-a-string/">
        </link>
        <updated>2020-04-15T12:31:12.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[208. Implement Trie (Prefix Tree)]]></title>
        <id>https://olegpt.top/post/208-implement-trie-prefix-tree/</id>
        <link href="https://olegpt.top/post/208-implement-trie-prefix-tree/">
        </link>
        <updated>2020-04-08T12:33:24.000Z</updated>
    </entry>
</feed>